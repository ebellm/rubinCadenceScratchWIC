#
# compareExtinctions.py
#
 
# Authors: Will Clarkson (UM-Dearborn) and Alessandro Mazzi (INAF)

# Started 2021-04-02
#

#
# Use Bovy's dustmaps and Alessandro Mazzi's STILISM_LOCAL.py to
# compare the lallement and bovy extinction predictions for a
# particular sight line.
#

# Bovy et al. and stilism_local - must be included
import mwdust
import stilism_local

# If we want to query planck2d for every sightline, not just those we
# tabulated
try:
    from dustmaps.planck import PlanckQuery
    PLANCK_2D = PlanckQuery()
except:
    PLANCK_2D = None

# Standard methods
import numpy as np

# for timings
import time

# For filename operations and optional directory creation
import os, glob

# To space the samples out in equatorial rather than galactic
from astropy.coordinates import SkyCoord
from astropy import units as u

from astropy.io import fits

# To determine spacings for samples about a central sight line
import healpy as hp

import matplotlib.pylab as plt
import matplotlib.gridspec as gridspec
plt.ion()

class lineofsight(object):

    """Evaluates E(B-V) vs distance for a particular line of sight. The
bovy et al. 2019 combined map can be passed in (as argument objBovy)
or can be re-imported here."""

    def __init__(self, l=0., b=4., \
                 distMaxPc=8000, distMinPc=0.5, distStepPc=10, \
                 distances=np.array([]), \
                 objBovy = None, Rv=3.1, \
                 objL19=None, \
                 distMaxCoarsePc = 17500., \
                 nDistBins = 400,
                 map_version='19'):

        # Sight line, max distance
        self.l = l
        self.b = b
        self.distMaxPc = distMaxPc
        self.distMinPc = distMinPc
        self.distStepPc = distStepPc

        # Maximum overall distance, *IF* we are using a coarser set of
        # bins for the bovy et al. distances than for the L19
        # distances.
        self.distMaxCoarsePc = distMaxCoarsePc

        # If we are generating distances to fit in a larger scheme
        # (where we need the same number of bins in every sight line),
        # we will need to enforce the total number of bins. If we're
        # letting stilism_local generate distances, this quantity is
        # ignored.
        self.nDistBins = nDistBins
        
        # Conversion factor from A_5555 to E(B-V)
        self.Rv=Rv
        
        # Distances generated by stilism_local, maximum distance along
        # this sight line for stilism_local
        if np.size(distances) > 0:
            self.distsPc = np.copy(distances)
        else:
            self.distsPc = np.array([])
        self.distLimPc = 1e9 # initialize very high

        # Map-relevant quantities follow.
        self.planckValue = 0. # planck 2d query at this sight line.
        
        # bovy et al. distance model - if not initialised
        if objBovy is None:
            self.objBovy = mwdust.Combined19()
        else:
            self.objBovy = objBovy

        # extinction evaluates
        self.ebvL19 = np.array([])
        self.ebvBovy = np.array([])

        # Set up L19 map
        
        # the version of LallementDustMap must be either '18' or '19',
        # as string
        if objL19 is None:
            self.lallementMap \
                = stilism_local.LallementDustMap(version=map_version,Rv=Rv)
        else:
            self.lallementMap = objL19
            
    def generateDistances(self, Verbose=False):

        """Generates a distance array appropriate for this sight
line. Fine-grained distances are used over the range in which L+19 is
defined, then switches over to a coarse-grained set of distances for
Bovy et al.

        """

        # Generate an array of "fine-grained" distances
        distsFine = stilism_local.generate_distances(self.distMaxPc,
                                                     self.distMinPc, \
                                                     self.distStepPc)

        # Find the maximum distance that fits inside the L19
        # volume. Currently the routine in stilism_local returns the
        # boolean and the xyz coords since those are needed for the
        # interpolation. We don't need those quantities here, though.
        distMax, _, _ = self.lallementMap.find_max_distance(self.l, self.b, \
                                                        distsFine)

        # OK now we set the maximum distance for the "fine" set of the
        # distances, adding a few steps onto the end to allow for
        # neighboring sight lines to take different paths through the
        # cube.
        self.distLimPc = distMax + 5*self.distStepPc

        # Now we generate the "fine" and "coarse" distance arrays and
        # abut them together.
        distsClose = stilism_local.generate_distances(self.distLimPc, \
                                                      self.distMinPc, \
                                                      self.distStepPc)

        # we have to determine the coarse step size dynamically too.
        nBinsFar = self.nDistBins - np.size(distsClose)

        # What we do if we sent in too few bins to begin with needs
        # some thought... I think for the moment it's better to warn
        # and extend the footprint in this case. We use a conditional
        # so that we can put the warning in (rather than use np.min()
        # in the above line). We could put in a conditional for
        # whether we actually want to do this (rather than just
        # crashing), but for the moment let's ensure this actually
        # does run all the way through...
        if nBinsFar < 0:
            print("generateDistances WARN - nFine > nTotal. Extending the coarse array to 10 elements. This may not be what you want...")
            nBinsFar = 10
            
        # We want the arrays to mesh more or less seamlessly. Here's
        # how: we use linspace to take the maximum close distance out
        # to the maximum total distance, WITHOUT the endpoints. Then
        # we find the step resulting and shift the array by that
        # distance.
        distsFar = np.linspace(np.max(distsClose), self.distMaxCoarsePc, \
                               nBinsFar, endpoint=False)
        # Update the step size and shift the coarse array by one step
        self.distStepCoarsePc = distsFar[1] - distsFar[0]
        distsFar += self.distStepCoarsePc
        
        #distMinFar = np.max(distsClose)+self.distStepCoarsePc
        #distsFar = np.linspace(distMinFar, self.distMaxCoarsePc, nBinsFar, \
        #                       endpoint=True)

        self.distsPc = np.hstack(( distsClose, distsFar ))

        # Ensure the limits sent to stilism_local are consistent with
        # this. If we're sending stilism a distance array then those
        # values should be ignored anyway, but it doesn't hurt to make
        # them consistent.
        self.distMinPc = np.min(self.distsPc)
        self.distMaxPc = np.max(self.distsPc)
        self.distStepPc = (self.distMaxPc - self.distMinPc) \
                          / np.size(self.distsPc)
        
        if Verbose:
            nbins = np.size(self.distsPc)
            stepFine = distsClose[1] - distsClose[0]
            stepFar  = distsFar[1] - distsFar[0]
            print("lineofsight.generateDistances INFO - nbins %i, fine step %.3f, coarse step %.3f" % (nbins, stepFine, stepFar))
        
    def getLallementEBV(self):

        """Evaluates the Lallement+19 extinction"""

        # we supply the get_ebv_lallement routine with our array of
        # distances. If it's zero length, get_ebv_lallement will
        # generate its own. Otherwise it uses the values we
        # supply. This leads to an apparently redundant set of
        # keywords in the call.
        l19, dists, distLim \
            = self.lallementMap.get_ebv(self.l, self.b, \
                                              self.distMaxPc, \
                                              self.distMinPc, \
                                              self.distStepPc, \
                                              distances=self.distsPc)

        # Pass the l19 values, converted to E(B-V)
        ## new 2021-04-05: not needed since LallementDustMap handles conversion automatically
        #self.ebvL19 = l19 / self.Rv
        self.ebvL19 = l19
        
        # pass the distance array generated to the instance, IF it
        # wasn't already generated.
        if np.size(self.distsPc) < 1:
            self.distsPc = np.copy(dists)
            self.distLimPc = np.copy(distLim)

    def getBovyEBV(self):

        """Evaluates Bovy et al. E(B-V) for this sight line"""

        self.ebvBovy = self.objBovy(self.l, self.b, self.distsPc/1000.)

        # extinctions cannot be negative
        bLo = self.ebvBovy < 0.
        self.ebvBovy[bLo] = 0.
        
    def getPlanck2D(self):

        """Gets the 2D planck value of the extinction for this sightline, if
dustmaps is present."""

        # Do nothing if the dustmaps.planck is not on the system
        if PLANCK_2D is None:
            return

        # planck2d expects astropy skycoo coordinates. Although the
        # method that called this instance may already have the coords
        # developed, it should be quick to generate one here.
        coo = SkyCoord(self.l*u.deg, self.b*u.deg, frame='galactic')
        self.planckValue = PLANCK_2D(coo)

    def showLos(self, ax=None, alpha=1.0, lw=1, zorder=5, \
                noLabel=False, \
                showPoints=False):

        """Adds a plot for the line of sight to the current axis"""

        # start an axis if one was not supplied
        newAx = False
        if ax is None:
            fig1 = plt.figure(1)
            fig1.clf()
            ax = fig1.add_subplot(111)
            newAx = True

        # hack for the labels
        labl19 = 'L+19'
        lablBov = 'Bovy'
        if noLabel:
            labl19 = ''
            lablBov = ''

        # show the points?
        marker=None
        markerB=None
        if showPoints:
            marker='o'
            markerB='s'
            
        b19 = self.distsPc <= self.distLimPc
        dumLlo = ax.plot(self.distsPc[b19], self.ebvL19[b19], 'k-', \
                         label=labl19, \
                         alpha=alpha, lw=lw, zorder=zorder, \
                         marker=marker, ms=2)

        dumLhi = ax.plot(self.distsPc[~b19], self.ebvL19[~b19], 'k--', \
                         alpha=alpha, lw=lw, zorder=zorder, \
                         marker=marker, ms=1)

        dumBo = ax.plot(self.distsPc, self.ebvBovy, 'r-', \
                        label=lablBov, \
                        alpha=alpha, lw=lw, zorder=zorder+1, \
                        marker=markerB, ms=1)

        # if we are doing a new axis, decorate it
        if not newAx:
            return

        self.decorateAxes(ax)

    def showDistMax(self, ax=None):

        """Draw an indicator showing the maximum distance for L19"""

        if ax is None:
            return

        if self.distLimPc > self.distMaxPc:
            return

        blah = ax.axvline(self.distLimPc, ls='--', color='k', alpha=0.3)
        
        #ymax = np.max(self.ebvL19)
        #dum = ax.plot([self.distLimPc, self.distLimPc], [0., ymax], \
            #'k--', alpha=0.3)
            
    def decorateAxes(self, ax=None):

        """One-liner to decorate the current plot axes appropriately for the
extinction vs distance plot"""

        if ax is None:
            return
        
        ax.set_xlabel('Distance (pc)')
        ax.set_ylabel('E(B-V)')
        ax.grid(which='both', zorder=1, color='0.5', alpha=0.5)
        ax.set_title('l=%.2f, b=%.2f' % (self.l, self.b))
        
#### Test the comparison

def testOneSightline(l=0., b=4., Rv=3.1, useCoarse=False):

    """Try a single sight line"""

    # Import the bovy et al. map so we don't have to re-initialize it
    # for each sight-line
    combined19 = mwdust.Combined19()
    
    los = lineofsight(l, b, objBovy=combined19, Rv=Rv)

    if useCoarse:
        los.generateDistances(Verbose=True)
    los.getLallementEBV()
    los.getBovyEBV()

    # show the line of sight
    los.showLos(showPoints=True)

def hybridSightline(lCen=0., bCen=4., \
                    nl=4, nb=4, \
                    maxPc=9000., minPc=0.5, stepPc=25, \
                    nside=64, \
                    pixFillFac=1.0, collisionArcmin=2., \
                    pctUpper=75., pctLower=25., \
                    Rv=3.1, \
                    distFrac=1., diffRatioMin=0.5, \
                    setLimDynamically=False, \
                    minEBV=1.0e-3, \
                    minDistL19=1000., \
                    returnValues = False, \
                    tellTime=True, \
                    doPlots=True, \
                    figName='', \
                    useTwoBinnings=True, \
                    nBinsAllSightlines = 500, \
                    distancesPc = np.array([]), \
                    hpid=-1, nested=False, \
                    objBovy=None, \
                    objL19=None, \
                    versionL19='19', \
                    dmaxL19=1e6,\
                    bridgeL19 = False, \
                    bridgeWidthL19 = 1000, \
                    planckMap=None, \
                    planckUpperLim = 15.):

    """Samples the Bovy et al. and Lallement et al. 2019 E(B-V) vs
    distance maps, constructed as the median E(B-V) vs distance curve
    over nl x nb samples about the central sight line. 

    if "returnValues" is set, this returns the E(B-V), distances,
    scale factor, and max distance for L19.

    A modified version of Alessandro Mazzi's
    "stilism_local.py" is used to query Lallement et al. 2019.
    
    REQUIREMENTS beyond the standard numpy and matplotlib: 

    stilism_local.py: Currently, the script "stilism_local.py" must be
    accessible on PYTHONPATH (or be in the current working directory),
    and it must be able to locate the "stilism_cube_2.h5" file.

    mwdust - Bovy's 3D extinction models and sampler.

    healpy - must be present on the system (to convert NSIDE into a
    pixel area). If mwdust successfully installed on your system then
    you probably already have this.

    If you want to query Planck in all the sight lines, Gregory
    Green's "mwdust" is also required.

    MORE INFO, ARGUMENTS:

    The median over all the samples is taken as the E(B-V) curve for
each of the two models. The Lallement et al. 2019 model is scaled to
match the Bovy et al. model at a transition distance. This transition
distance can be determined dynamically or set to a fixed fraction of
the maximum distance of validity of the Lallement et al. 2019
model.

    ARGUMENTS:

    lCen, bCen = central line of sight, in degrees.

    nl, nb = number of points in l, b about which to draw
    samples. (The samples will be drawn in a grid (nl x nb) about the
    central line of sight.)

    maxPc, minPc, stepPc = max, min, stepsize for the distance in
    parsecs along the line of sight. (minPc should be small but not
    zero: 0.5 pc seems a sensible level to use.)

    nside = Healpix NSIDE (used to estimate the side-length for the
    square region sampled)

    pixFillFrac = fraction of the side-length of the healpix to sample
    with our pointings (the default is to sample out to the corners of
    the pixel).

    collisionArcmin = closest distance a sample can fall to the line
    of sight without being rejected as a duplicate of the central line
    of sight.

    pctUpper, pctLower = lower and upper percentiles for displaying
    the variation of E(B-V) within the healpix. (May be ambiguous to
    interpret for small (nl x nb).)

    Rv = scale factor converting L19's A_555 to E(B-V). Default 3.1.

    distFrac = fraction of the L19 maximum distance to use as a
    default for the overlap point between L19 and Bovy.

    diffRatioMin = minimum fractional difference btween L19 and Bovy
    for the two predictions to be considered "discrepant". Used if
    estimating the overlap distance dynamically.

    setLimDynamically: setting the overlap distance dynamically?

    minEBV = minimum value for the Bovy extinction. Bovy points below
    this value are ignored.

    minDistL19 = minimum acceptable dynamically determined overlap
    distance. If the dynamically determined distance is less than this
    value, the default (distFrac x max(dist_L19) is used instead.

    tellTime = Report screen output, including the timing.

    doPlots = prepare plots?

    returnValues = return the extinction and distances?

    figName = filename for output figure file. If length < 3, no
    figure is saved to disk.

    useTwoBinnings: Uses finer distance bins for L19 than for Bovy et al., such that the total number of bins is the same for all sight lines.

    nBinsAllSightlines = number of bins total for the sightlines

    distancesPc = input array of distances in parsecs. If supplied, all the clever distance methods here are ignored in favor of the input distances.

    hpid: if >0, then a healpix ID is being supplied, and will
    override the choice of l, b. The field center is constructed from
    this healpix id.

    nested: if using hpids, is this with NESTED? Default is False
    because sims_maf seems to use RING by default.

    objBovy = bovy et al. dust object. Defaults to None and is
    re-initialized in this method. But, could be passed in here too to
    save time.

    objL19 = Lallement et al. map object. Defaults to None and is
    re-initialized in this method using the Rv and versionL19
    arguments

    versionL19 = Version of Lallement et al. to use if we are
    re-initializing L19 here.

    dmaxL19 = Maximum distance for Lallement et al. profile. Defaults
    to a very large number so the profile up to the intrinsic maximum
    distance of the map is used. Setting to zero disables Lallement's
    map.  Setting instead to a negative value will use Bovy alone if
    non-zero for the line of sight, otherwise only Lallement.

    bridgeL19 - if True, L19 is taken as "correct", and the E(B-V) is
    extended from the value of L+19 at the maximum distance, to the
    value of Bovy et al. at the maximum distance plus distance
    bridgeWidthL19

    bridgeWidthL19 - the distance interval over which the above
    extension is to take place.

    planckMap = healpix 2d map of Planck E(B-V) predictions. Ignored
    if the query coords were not healpix, OR if Green's "dustmaps" is
    available on the system.

    planckUpperLim = upper limit for planck E(B-V) to be considered
    "sensible"

    EXAMPLE CALL:

    compareExtinctions.hybridSightline(0, 4, figName='test_l0b4_ebvCompare.png', nl=5, nb=5, tellTime=True)

    """

    # For our timing report
    t0 = time.time()
    
    # generate samples in l, b to sample a typical healpix
    pixSideDeg = hp.nside2resol(nside, arcmin=True) / 60.

    # how far to the edge of the pixel do we go in our samples?
    pixEdge = np.min([pixFillFac, 1.0])
    
    # now we generate the grid of samples
    dL = pixSideDeg * pixEdge * np.linspace(-1., 1., nl, endpoint=True)
    dB = pixSideDeg * pixEdge * np.linspace(-1., 1., nb, endpoint=True)

    # create meshgrid and ravel into 1D arrays
    ll, bb = np.meshgrid(dL, dB)
    
    # convert the field center into equatorial so that we can generate
    # the samples within the healpix
    planckCen = 0.
    if hpid < 0:
        cooGAL = SkyCoord(lCen*u.deg, bCen*u.deg, frame='galactic')
        raCen = cooGAL.icrs.ra.degree
        deCen = cooGAL.icrs.dec.degree
    else:
        raCen, deCen = hp.pix2ang(nside, hpid, nested, lonlat=True)
        cooEQ = SkyCoord(raCen*u.degree, deCen*u.degree, frame='icrs')
        lCen = cooEQ.galactic.l.degree
        bCen = cooEQ.galactic.b.degree

        # fudge for wraparound, to use the same scheme as the samples
        if lCen > 180:
            lCen -= 360.
        
        # do we have a planck map?
        if planckMap is not None:
            planckCen = planckMap[hpid]
        
    vRA = ll.ravel() + raCen
    vDE = bb.ravel() + deCen

    # Ensure the coords of the samples actually are on the sphere...
    bSampl = (vDE >= -90.) & (vDE <= 90.)
    vRA = vRA[bSampl]
    vDE = vDE[bSampl]
    
    cooSamples = SkyCoord(vRA*u.deg, vDE*u.deg, frame='icrs')
    vL = np.asarray(cooSamples.galactic.l.degree)
    vB = np.asarray(cooSamples.galactic.b.degree)

    # handle the wraparound
    bLhi = vL > 180.
    vL[bLhi] -= 360.
    
    #vL = ll.ravel() + lCen
    #vB = bb.ravel() + bCen

    # knock out any points that are closer than distanceLim to the
    # central sight line
    offsets = (vL-lCen)**2 + (vB - bCen)**2
    bSamplesKeep = (offsets*3600. > collisionArcmin**2) & \
                   (vB >= -90.) & (vB <= 90.)

    if np.sum(bSamplesKeep) < 1:
        print("hybridSightline WATCHOUT - no samples kept. Check your line of sight coordinates are valid.")
        return
    
    vL = vL[bSamplesKeep]
    vB = vB[bSamplesKeep]

    # OK now we can proceed. First build the line of sight for the
    # center, then repeat for the nearby sight lines. If we already
    # initialized the bovy dust object somewhere else, we can pass it
    # in. If not initialized, then we initialize here.
    if objBovy is None:
        combined19 = mwdust.Combined19()
    else:
        combined19 = objBovy

    # L+19 object-oriented map - can be passed in
    if objL19 is None:
        L19map \
            = stilism_local.LallementDustMap(version=versionL19,Rv=Rv)
    else:
        L19map = objL19
        
    # for our timing report: how long did it take to get this far?
    t1 = time.time()
    
    # now build the line of sight
    losCen = lineofsight(lCen, bCen, maxPc, minPc, stepPc, \
                         objBovy=combined19, Rv=Rv, \
                         objL19=L19map, \
                         nDistBins=nBinsAllSightlines, \
                         distances=distancesPc)

    # If a distances array was not supplied, AND we want to use our
    # two-binning scheme to generate the distances, then generate the
    # distances.
    if useTwoBinnings and np.size(distancesPc) < 1:
        losCen.generateDistances(Verbose=tellTime)
    
    losCen.getLallementEBV()
    losCen.getBovyEBV()
    losCen.getPlanck2D()

    # Set up a figure...
    if doPlots:
        fig1 = plt.figure(1, figsize=(12,6))
        fig1.clf()
        fig1.subplots_adjust(wspace=0.3, hspace=0.3)

        # let's try using gridspec to customize our layout
        gs = fig1.add_gridspec(nrows=2, ncols=3)
        ax1 = fig1.add_subplot(gs[:,0:2])

        # ax1=fig1.add_subplot(121)
        
        losCen.showLos(ax=ax1, alpha=0.1, lw=2, zorder=10, noLabel=True)
        losCen.decorateAxes(ax1)
        losCen.showDistMax(ax1)

        ## Show the planck prediction if we have it
        #if losCen.planckValue > 0:
        #    ax1.axhline(losCen.planckValue, ls='--', \
        #                label='Planck 2D', color='g')
        
    # construct arrays for all the samples as a function of
    # distance. We'll do this vstack by vstack.
    stackDist = np.copy(losCen.distsPc) # to ensure they're all the same...
    stackL19 = np.copy(losCen.ebvL19)
    stackBovy = np.copy(losCen.ebvBovy)

    # Any 2D maps we use will only have a single value for each LOS.
    stackPlanck2D = np.array([losCen.planckValue])
    
    # now loop through the samples. We pass in the same distance array
    # as we used for the central line of sight, IF we are using our
    # two-binning scheme.
    for iSample in range(np.size(vL)):
        distsInput = np.copy(distancesPc) # use input distances if any
                                          # were given.
        if useTwoBinnings:
            distsInput = losCen.distsPc 
        losThis = lineofsight(vL[iSample], vB[iSample], \
                              maxPc, minPc, stepPc, \
                              objBovy=combined19, \
                              objL19=L19map, \
                              Rv=Rv, \
                              distances=distsInput)
        losThis.getLallementEBV()
        losThis.getBovyEBV()
        losThis.getPlanck2D()
        
        #if doPlots:
        #    # Show the planck prediction if we have it
        #    if losThis.planckValue > 0:
        #        ax1.axhline(losThis.planckValue, ls='--', \
        #                    label='', color='g')

        
        #if doPlots:
        #    losThis.showLos(ax=ax1, alpha=0.3, lw=1, zorder=3)

        # accumulate to the stacks so that we can find the statistics
        # across the samples
        stackDist = np.vstack(( stackDist, losThis.distsPc ))
        stackL19  = np.vstack(( stackL19,  losThis.ebvL19 ))
        stackBovy = np.vstack(( stackBovy, losThis.ebvBovy ))

        # stack any 2D maps we have
        stackPlanck2D = np.hstack(( stackPlanck2D, losThis.planckValue ))
        
    # now compute the statistics. We do the median and the upper and
    # lower percentiles.
    distsMed = np.median(stackDist, axis=0)
    ebvL19Med = np.median(stackL19, axis=0)    
    ebvBovyMed = np.median(stackBovy, axis=0)

    # add any 2D extinction arrays we're using. Note that along some
    # sightlines (like 0,0), Planck produces very high E(B-V)
    # predictions - like 300. So set an upper limit.
    bPlanck = stackPlanck2D < planckUpperLim
    planck2DMed = 0.
    
    if np.sum(bPlanck) > 0:
        planck2DMed = np.median(stackPlanck2D[bPlanck])

    # If dustmaps is not on this system, then substitute in the planck
    # map at the central LOS if one was supplied.
    if planck2DMed < 1e-5 and planckCen is not None:
        planck2DMed = np.copy(planckCen)
        
    # find the scale factor for the Rv factor that causes L19 to line
    # up with Bovy et al. along the sight line, out to our desired
    # comparison distance.

    # We set a default comparison point: some fraction of the maximum
    # distance along this sight line for which we have the L+19 model.
    distCompare = losCen.distLimPc * distFrac

    # Use max distance provided by the user if required. 
    usemaxdist = False
    if 0. <= dmaxL19 < losCen.distLimPc:
        distCompare = dmaxL19
        usemaxdist=True

        if tellTime:
            print("compareExtinctions.hybridSightline INFO - Using user provided max dist for L+19.")
        
    elif dmaxL19 < 0:  # replaced "== -1" with "<0"
        
        # Specify that distance should not be changed by other operations
        usemaxdist=True
        # Do not use Lallement if Bovy has non-zero values
        if ebvBovyMed.sum()!=0:
            distCompare = 0

        # else use the full extent of the profile
#    elif dmaxL19<0:
#        raise NotImplemented("The value of dmax has to be either -1 or >=0, currently {}.".format(dmaxL19))



    if usemaxdist and doPlots:
        ax1.axvline(distCompare,color='r',linestyle='dotted',label='dmaxL19')

    # We can also try to set the decision distance dynamically. Here I
    # find all the distances for which the L+19 extinction is within
    # fraction "diffRatioMin" of the Bovy et al. extinction, and find
    # the maximum distance for which the two sets are this close. If
    # that distance is less than some cutoff ("minDistL19") then the
    # dynamically estimated max distance is discarded.
    if setLimDynamically and not usemaxdist:
        bNear = (distsMed <= losCen.distLimPc) & \
                (ebvL19Med > 0) & (ebvBovyMed > 0 ) & \
                (np.abs(ebvBovyMed / ebvL19Med - 1.0) < diffRatioMin)
        if np.sum(bNear) > 0:
            # what minimum distance satisfied this expression?
            distMinCalc = np.max(distsMed[bNear])

            # Only apply the revised limit if it is farther than our
            # desired minimum.
            if distMinCalc > minDistL19:
                distCompare = distMinCalc
            
            
    # now we set our scale factor based on comparison to Bovy. Some
    # regions of Bovy still produce zero E(B-V) for all distances, so
    # we set a minimum (if bovy AT THE COMPARISON POINT is below our
    # threshold minEBV, then we do no scaling).
    rvFactor = 1. # our default: no scaling.
    iMaxL19 = np.argmin(np.abs(distsMed - distCompare))
    if ebvBovyMed[iMaxL19] > minEBV:
        rvFactor = ebvL19Med[iMaxL19] / ebvBovyMed[iMaxL19]

    # 2021-04-05 WIC - if we have the planck2d map to hand, then for
    # the cases where Bovy does not seem to have coverage, scale L19
    # to the median Planck value.
    else:
        if planck2DMed > 0. and distCompare > 0:
            rvFactor = ebvL19Med[iMaxL19] / planck2DMed
        
    RvScaled = Rv * rvFactor

    ### Merge the two median curves. This will be our E(B-V) curve
    ### with distance.
    ebvHybrid = np.copy(ebvBovyMed)
    b19 = distsMed < distCompare
    ebvL19scaled = ebvL19Med/rvFactor

    # 2021-04-07 If the user prefers to accept L+19 and extend it to
    # meet bovy et al. I think it happens here - we change the meaning
    # of ebvL19Scaled (to ebv19 "replaced"):
    if bridgeL19 and distCompare > 0 and ebvBovyMed[iMaxL19] > minEBV:

        distRight = np.min([distCompare + bridgeWidthL19, \
                            np.max(distsMed)])

        if tellTime:
            print("compareExtinctions.hybridSightline INFO - bridging L19 to bovy et al. 19 from distance %.1f - %.1f" % (distCompare, distRight))

        
        # find the nearest values of the two extinctions to use
        iLeft =  np.argmin(np.abs(distsMed - distCompare))
        iRight = np.argmin(np.abs(distsMed - distRight))

        # Evaluate the straight line parameters that take L19 to Bovy
        m, c = linkStraightline(distsMed[iLeft], distsMed[iRight], \
                                ebvL19Med[iLeft], ebvBovyMed[iRight])

        # we re-initialize hybrid including the bridge
        ebvHybrid = np.copy(ebvL19Med)

        # ... apply the transformation along the bridge...
        ebvHybrid[iLeft:iRight] = m*distsMed[iLeft:iRight] + c

        # ... and everything to the right of the bridge is Bovy
        ebvHybrid[iRight::] = ebvBovyMed[iRight::]

        # Finally, we need to re-define the boolean "b19" so that it
        # doesn't switch scaled L19 back in again.
        b19 = np.isnan(ebvHybrid)

        
    #ebvHybrid[b19] = ebvL19Med[b19]/rvFactor
    bBovBad = ebvHybrid < minEBV
    if dmaxL19==-1:
        # Only use Lallement if Bovy is zero
        # distCompare is non-zero if Bovy is zero, use only Lallement
        if distCompare!=0:
            ebvHybrid = ebvL19Med
            
        if len(bBovBad)>0:
            if tellTime:
                print(("compareExtinctions.hybridSightline WARN - Values in the E(B-V) "
                       "Bovy profile are not larger than the requested minimum of %.2f at all distances." % (minEBV)))
        # If distCompare is zero, Bovy is non-zero and will be the only profile used
    else:
        if distCompare>0:
            ebvHybrid[b19] = ebvL19scaled[b19]
        
            # ebvHybrid[bBovBad] = ebvL19Med[bBovBad]/rvFactor
            ebvHybrid[bBovBad] = ebvL19scaled[bBovBad]

    # If the user's choices have led to a profile that is zero at all
    # distances, warn the user (unless the user has suppressed text
    # output)
    if np.all(ebvHybrid==0):
        if tellTime:
            print("compareExtinctions.hybridSightline WARN - The E(B-V) profile is zero at all distances!")

    if tellTime:
        t2 = time.time()
        dtBovy = t1 - t0
        dtSample = t2 - t1
        dtTotal = t2 - t0
        
        print("TIMING: setup:%.2e s, querying:%.2e s, total:%.2e s" \
              % (dtBovy, dtSample, dtTotal))
    
    # if not plotting, return
    if not doPlots:
        if returnValues:
            return ebvHybrid, distsMed, rvFactor, distCompare
        else:
            return
        
    ## Now we compute the upper and lower levels for plotting. I am
    ## not certain if it's better to use percentiles or to use the
    ## standard deviation (there is a tradeoff when there are few
    ## samples) so both are computed for the moment.
    ebvL19Std = np.std(stackL19, axis=0)
    ebvL19Levs = np.percentile(stackL19, [pctLower, pctUpper],\
                                axis=0)
    
    ebvBovyStd = np.std(stackBovy, axis=0)
    ebvBovyLevs = np.percentile(stackBovy, [pctLower, pctUpper],\
                                axis=0)

    # same for planck2d
    ebvPlanck2DStd = np.std(stackPlanck2D)
    ebvPlanck2DLevs = np.percentile(stackPlanck2D, [pctLower, pctUpper])
    
    ### Now we plot the regions of coverage to the percentile limits,
    ### for the bovy and for the L+19 predictions.
    dumLevsL19 = ax1.fill_between(distsMed, ebvL19Levs[0], ebvL19Levs[1], \
                                  zorder=9, alpha=0.4, color='0.5')
    dumLevsBovy = ax1.fill_between(distsMed, ebvBovyLevs[0], ebvBovyLevs[1], \
                                  zorder=9, alpha=0.3, color='r')

    ### Show the median levels for Bovy and for L+19
    dumMedsL19  = ax1.plot(distsMed, ebvL19Med, color='k', ls='-.', \
                           zorder=20, lw=2, \
                           label=r'L19, R$_V$=%.2f' % (Rv))
    dumMedsBovy = ax1.plot(distsMed, ebvBovyMed, color='r', ls='--', \
                           zorder=21, lw=2, label='Bovy median')

    # if we have it, show the levels for planck
    dumPlanckMed = ax1.axhline(planck2DMed, color='g', ls='-', lw=2, \
                               label='Planck 2D', alpha=0.7)
    
    # Overplot the hybrid EBV curve
    dumHybrid = ax1.plot(distsMed, ebvHybrid, ls='-', color='c', lw=6, \
                         label='Hybrid E(B-V)', zorder=31, alpha=0.5)
    
    # show lallement et al. scaled up to bovy et al. at the transition
    # -- IF we wanted to do the scaling...
    coloScaled='b'
    if not bridgeL19:
        dumScal = ax1.plot(distsMed[b19], ebvL19scaled[b19], \
                           color=coloScaled, \
                           lw=2, \
                           ls=':', \
                           label=r'L19, R$_{V}$=%.2f' % (RvScaled), \
                           zorder=35, alpha=0.75)
        dumLevsScal = ax1.fill_between(distsMed[b19], \
                                       ebvL19Levs[0][b19]/rvFactor, \
                                       ebvL19Levs[1][b19]/rvFactor, \
                                       color=coloScaled, \
                                       alpha=0.2, \
                                       zorder=34)
        
        #sAnno = "Green dashed: L19 w/ Rv=%.2f" % (RvScaled)
        #dum = ax1.annotate(sAnno, (0.95,0.05), xycoords='axes fraction', \
        #                   ha='right', va='bottom', color='g')

    # override the axis title:
    sTitle = '(lCen, bCen)=(%.2f, %.2f), NSIDE=%i. %i samples' % \
                  (lCen, bCen, nside, 1+len(vL))
    # add the levels information
    sTitle = '%s. Pct lower, upper = %.1f, %.1f' % (sTitle, pctLower, pctUpper)
    ax1.set_title(sTitle)

    # ok NOW we do the legend.
    leg = ax1.legend(loc=0, frameon=True, facecolor='w', framealpha=1.)

    # Now show these over the figure
    #dumAvgL19 = ax1.errorbar(distsMed, ebvL19Med, \
    #                         yerr=ebvL19Std, \
    #                         ls=None, ms=5, 
    #                         zorder=20)

    #dumAvgL19 = ax1.errorbar(distsMed, ebvBovyMed, \
    #                         yerr=ebvBovyStd, \
    #                         ls=None, ms=5, 
    #                         zorder=20)

    # Show a panel giving the sight lines looked at here. We will want
    # the maximum bovy extinctions for each (since that goes farther):
    maxBovy = stackBovy[1::,-1] # for our colors, not including central

    maxPlanck2D = stackPlanck2D[1::]

    
    # debug - what sight lines are we looking at here?
    #fig2 = plt.figure(2, figsize=(3,3))
    #fig2.clf()
    #ax2 = fig1.add_subplot(224)

    # If we have planck2d as well as bovy, show both. Otherwise don't
    # show both.

    lAx = [fig1.add_subplot(gs[1,2])]
    lCo = [maxBovy]
    lLa = ['E(B-V), Bovy']
    lGood = [np.isfinite(maxBovy)]
    vmin = None
    vmax = None
    
    if np.max(stackPlanck2D) > 1e-3:
        lAx.append(fig1.add_subplot(gs[0,2]))
        lCo.append(maxPlanck2D)
        lLa.append('E(B-V), Planck')
        bPla = maxPlanck2D < planckUpperLim
        lGood.append(bPla) # was set many lines above.
        
        ebvBoth = np.hstack(( maxBovy, maxPlanck2D[bPla] ))
        vmin = np.min(ebvBoth)
        vmax = np.max(ebvBoth)
        
    for iAx in range(len(lAx)):
        ax2 = lAx[iAx]
        vColor = lCo[iAx]
        labl = lLa[iAx]

        bb = lGood[iAx]
        
        #ax2 = fig1.add_subplot(gs[1,2])
        dumCen = ax2.plot(lCen, bCen, 'm*', ms=20, zorder=1)
        dumSamp = ax2.scatter(vL[bb], vB[bb], c=vColor[bb], \
                              zorder=5, cmap='Greys', \
                              edgecolor='0.5', marker='s', s=49, \
                              vmin=vmin, vmax=vmax)

        # show sightlines that failed
        if np.sum(~bb) > 0:
            blah = ax2.scatter(vL[~bb], vB[~bb], c='r', \
                               zorder=1, alpha=0.25, \
                               marker='x', s=36)

        cbar = fig1.colorbar(dumSamp, ax=ax2, label=labl)
        ax2.set_xlabel('l, degrees')
        ax2.set_ylabel('b, degrees')
        ax2.grid(which='both', zorder=1, color='0.5', alpha=0.5)
        ax2.set_title('Samples about %.2f, %.2f' % (lCen, bCen), \
                      fontsize=9)
    # fig2.subplots_adjust(left=0.25, bottom=0.25)

    # save the figure to disk
    if len(figName) > 3:
        fig1.savefig(figName, overwrite=True)

    if returnValues:
        return ebvHybrid, distsMed, rvFactor, distCompare

def linkStraightline(xLeft=0., xRight=0., yLeft=0., yRight=0.):

    """Given (x,y) points for the left- and right-ends of a straight line,
return the coefficients of the straight line m, c from y = mx + c.

    """

    if np.abs(xRight - xLeft) < 1.0e-3:
        return 1., 0.

    m = (yRight - yLeft) / (xRight - xLeft)

    c = yLeft - m*xLeft

    return m, c
    
def loopSightlines(nside=64, imin=0, imax=25, \
                   nbins=500, nested=False, \
                   nl=4, nb=4, tellTime=False, \
                   reportInterval=100, \
                   fitsPath='', \
                   dirChunks='./ebvChunksRedo', \
                   fracPix=1., \
                   map_version='19', \
                   Rv=3.1, \
                   dmaxL19=1e6, \
                   bridgeL19=False, \
                   bridgeWidthL19 = 1000):

    """Wrapper: samples the 3D extinction hybrid model for a range of
    healpixels

    nside = healpix nside
 
    imin, imax = first and last hpids to use 

    nbins = number of distance bins to use for each sightline

    nl, nb = number of samples to use around each sight line

    reportInterval = write do disk (and/or provide screen output)
    every this many healpix

    fitsPath = if >3 characters, the path to output fits file that
    overrides auto-generated output path

    dirChunks = if auto-generating the output path, the directory into
    which the file will go. Ignored if fewer than 4 characters.

    map_version = version of the L+19 map to send to the sightlines

    Rv = Rv needed for the L+19 map object

    ---

    Example call:

    To loop through NSIDE=64 healpix IDs 999-1019:

    compareExtinctions.loopSightlines(64, 999, 1019, reportInterval=10, nl=4, nb=4, fracPix=0.8, nbins=500) 

    """

    # set up the healpix quantities
    npix = hp.nside2npix(nside)

    print("loopSightlines INFO: nside %i, npix %i, %.3e" \
          % (nside, npix, npix))
    
    # How far through this are we going to go?
    if imax < 0 or imax > npix:
        imax = npix

    # set imin appropriately
    if imin > imax:
        imin = np.max([imax - 25, 0])
        
        print("loopSightlines WARN - supplied imax > imin. Defaulted to %i, %i" % (imin, imax))
        
    # Number of sightlines
    nSightlines = imax - imin

    # let's construct a filename for this segment so we can keep track
    # of them later.
    if len(fitsPath) < 4:
        fitsChunk = 'ebv3d_nside%i_hp%i_%i.fits' % (nside, imin, imax)
        if len(dirChunks) > 3:
            fitsPath = '%s/%s' % (dirChunks, fitsChunk)
            if not os.access(dirChunks, os.R_OK):
                dirChunks = os.makedirs(dirChunks)
        else:
            fitsPath = fitsChunk[:]
                
    # set up distance and E(B-V) arrays for only the ones we will be
    # running. We also store the healpix IDs so that we could do this
    # in pieces and then stitch them together later.
    shp = (nSightlines, nbins)

    # set up the arrays we'll be using
    hpids = np.arange(imin, imax)
    dists = np.zeros(shp)
    ebvs  = np.zeros(shp)

    # Let's keep track of the scale factor we used to merge L19 with
    # Bovy et al, as well as the distance at which the scaling was
    # done:
    sfacs = np.ones((nSightlines,2))

    # Set up header information for the inevitable serialization. I
    # think astropy has a nice way to do this, for the moment we can
    # build one with a dictionary.
    dMeta = {'nside':nside, 'nested':nested, \
             'hpmin':imin, 'hpmax':imax, \
             'nbins':nbins, 'nl':nl, 'nb':nb, \
             'fracPix':fracPix}

    dMeta['Rv'] = Rv
    dMeta['mapvers'] = map_version
    
    # 2021-04-05: if planck_2d is available on this system, add this
    # to the header (we do not yet have any option to deactivate the
    # substitution if present).
    dMeta['PlanckOK'] = PLANCK_2D is not None

    # 2021-04-07: Now that we have options for how we handle L19 and
    # Bovy merging, pass the choices to the metadata so that it
    # appears in the fits header.
    dMeta['dmaxL19'] = dmaxL19
    dMeta['bridgL19'] = bridgeL19
    dMeta['bridgwid'] = bridgeWidthL19
    
    # For reporting the sightlines to terminal
    tStart = time.time()
    
    # OK now loop through this. We don't want to have to redo the bovy
    # initialization for each sight line, so let's initialize it here.
    print ("loopSightlines - initializing Bovy...")
    combined19 = mwdust.Combined19()

    # We also initialize the Lallement+19 map object
    print("loopSightlines - initializing L19...")
    l19 = stilism_local.LallementDustMap(version=map_version,Rv=Rv)

    print("loopSightlines - starting loops:")
    
    for iHP in range(np.size(hpids)):    
        ebvsThis, distsThis, \
            rvFactor, distCompare  \
            = hybridSightline(0., 0., \
                              nl=nl, nb=nb, \
                              setLimDynamically=False, \
                              useTwoBinnings=True, \
                              nBinsAllSightlines=nbins, \
                              Rv=Rv, \
                              pixFillFac=fracPix, \
                              nested=nested, \
                              nside=nside, \
                              objBovy=combined19, \
                              objL19=l19, \
                              doPlots=False, \
                              tellTime=tellTime, \
                              dmaxL19=dmaxL19, \
                              bridgeL19=bridgeL19, \
                              bridgeWidthL19=bridgeWidthL19, \
                              returnValues=True, \
                              hpid=hpids[iHP])

        # now put the results into the master arrays by row number
        # (which is why we loop through the length of the hp array and
        # not the hpids themselves):
        dists[iHP] = distsThis
        ebvs[iHP] = ebvsThis
        sfacs[iHP][0] = rvFactor
        sfacs[iHP][1] = distCompare
        
        # Write to disk every so often
        if iHP >= reportInterval and iHP % reportInterval < 1:
            writeExtmap(hpids, dists, ebvs, sfacs, \
                        dMeta=dMeta, \
                        fitsPath=fitsPath)

            print("loopSightlines INFO: %i of %i: hpid %i: %.2e s" \
                  % (iHP, nSightlines, hpids[iHP], time.time()-tStart))
            
    # use our method to write to disk
    writeExtmap(hpids, dists, ebvs, sfacs, \
                        dMeta=dMeta, \
                        fitsPath=fitsPath)

def writeExtmap(hpids=np.array([]), dists=np.array([]), \
                ebvs=np.array([]), sfacs=np.array([]), \
                masks=np.array([]), \
                dMeta={}, header=None, fitsPath='test.fits'):

    """Writes extinction map segment to fits. HDUs are, in this order:

    hpids, distance bins, E(B-V)s, scale factors = data arrays to write

    masks = optional boolean mask array

    dMeta = dictionary of metadata keywords to pass

    header = template header to send to the primary HDU

    fitsPath = filename for output file"""

    if np.size(hpids) < 1:
        return

    # Generate primary header, accepting template header if given
    hdu0 = fits.PrimaryHDU(hpids, header=header)
    for sKey in dMeta.keys():
        hdu0.header[sKey] = dMeta[sKey]

    # ... then the secondary arrays, which we will serialize as image hdus:
    hdul = fits.HDUList([hdu0])

    # now we append them
    for thisArr in [dists, ebvs, sfacs, masks]:

        hdul.append(fits.ImageHDU(thisArr))
    
    hdul.writeto(fitsPath, overwrite=True)

    # close the hdulist
    hdul.close()

def mergeMaps(sSrch='ebv3d_nside64_*fits', \
              pathJoined=None):

    """Given partial healpix maps, merge them into a single all-sky hp
map. A list of paths matching the search string is constructed, and
the all-sky map constructed by slotting in the populated rows from the
individual files.

    """

    lPaths = glob.glob(sSrch)
    if len(lPaths) < 1:
        print("mergeMaps WARN - no paths match string %s" % (sSrch))
        return


    if pathJoined is None:
        pathJoined = os.path.join(extmaps_dir,'merged_ebv3d_nside64.fits')
        print("Output path set to",pathMap)
    # ensure the output file doesn't overwrite any of the input files
    elif len(pathJoined) < 4:
        pathJoined = os.path.join(extmaps_dir,'test_mergedmaps.fits')
    
    if os.path.isfile(pathJoined):
        raise FileExistsError(pathJoined)

    # if the joined path is in the path of files, remove it from the
    # list to consider and prepend "tmp_" to the output path. This
    # should guard against any overwriting of input files.
    if pathJoined in lPaths:
        print("mergeMaps INFO - output path %s already in input path list. Removing from input path list and using a different output path." % (pathJoined))
        lPaths.remove(pathJoined)
        pathJoined = 'tmp_%s' % (os.path.split(pathJoined)[-1])
        
    # read the healpix info from the header of the first file in the
    # list. For the moment we trust the header rather than
    # constructing this information from the input data.
    hdr0 = fits.getheader(lPaths[0])

    try:
        nested = hdr0['NESTED']
        nside = hdr0['NSIDE']
        nbins = hdr0['NBINS']
    except:
        print("mergeMaps WARN - problem reading header keywords from %s" \
              % (lPaths[0]))
        return
        
    # Now we construct our master arrays.
    npix = hp.nside2npix(nside)

    # hpid, distance, ebvs, and a mask array. The mask array follows
    # np.masked convention that the mask is FALSE for GOOD points.
    hpidsMaster = np.arange(npix)
    distsMaster = np.zeros((npix, nbins))
    ebvsMaster = np.zeros((npix, nbins))
    sfacsMaster = np.zeros((npix, 2))
    maskMaster = np.ones((npix, nbins), dtype='uint')

    # OK now we slot in the various pieces
    for path in lPaths:
        hdul = fits.open(path)
        rowsThis = hdul[0].data

        distsMaster[rowsThis] = hdul[1].data
        ebvsMaster[rowsThis] = hdul[2].data
        sfacsMaster[rowsThis] = hdul[3].data

        # This is a little clunky, since we're allowing for the
        # possibility that the input data might or might not have mask
        # data written, and that mask data may or may not be zero
        # sized.
        hasMask = False
        if len(hdul) > 4:
            if np.size(hdul[4].data) > 0:
                maskMaster[rowsThis] = hdul[4].data
                hasMask = True

        if not hasMask:
            maskMaster[rowsThis, :] = 0
            
        # Close the hdulist before moving on
        hdul.close()

    # now we have our combined arrays and template header. Write them!
    # (2021-04-07 now not with the mask, since I don't think I know
    # how it will be used...)
    writeExtmap(hpidsMaster, distsMaster, ebvsMaster, sfacsMaster, \
                header=hdr0, \
                fitsPath=pathJoined)
